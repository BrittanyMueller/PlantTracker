/*
 * (C) Copyright 2023 Brittany Mueller and Larry Milne (https://www.larrycloud.ca)
 *
 * This code is distributed on "AS IS" BASIS,
 * WITHOUT WARRANTINES OR CONDITIONS OF ANY KIND.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author: qawse3dr a.k.a Larry Milne
 * @author: BrittanyMueller
 */

syntax = "proto3";

option java_multiple_files = true;
option java_package = "grpc.planttracker";
package planttracker.grpc;

/*
 * App to server requests??? Bee help me here I am not sure what the interface should look like
 */
service PlantTracker {
  // should these all be one rpc call and just sub types??
  // rpc AddPlant(Plant) returns (Result);
  // rpc DelPlant(string plant_name) returns (Result);

  // rpc AddLight(Light) returns (Result);
  // rpc DelLight(string light_name) returns (Result);
}

/*
 * This service will act as a listener for plant events, as well as reporiting sensors.
 * Because the PlantListener must act as a client so we don't need to deal with networking configurations for clients we
 * will do a long poll waiting for requests as they come in for the server -> client
 *
 * Main responsibilites for the listener are:
 *  1: add/remove plants/ light sensors
 *  2: requesting Live data from sensor
 *  3: setting baselines for plant light and moisture level.
 */
service PlantListener {
  rpc Initialze(PlantListenerConfig) returns (Result);

  rpc ReportSensor(PlantDataList) returns (Result);

  // Duplex which will be passed back and forth with ListenerRequest holding the result of the last operation.
  // On First operation it will always be return_code 0.
  rpc PollRequest(stream ListenerResponse) returns (stream ListenerResponse);
}

message Result {
  int64 return_code = 1;
  optional string error = 2;
}

message PlantListenerConfig {
  string name = 1;
  repeated Plant plants = 2;
  repeated Light lights = 3;
}

message PlantDataList {
  repeated PlantData data = 1;
}

message PlantData {
  int64 plant_id = 1;
  MoistureSensorData moisture = 2;
  LightSensorData light = 3;
}

message MoistureSensorData {
  double moisture_level = 1;  // Percent
  int32 sensor_value = 2;     // Actual sensor value 0-SENSOR_MAX
}

message LightSensorData {
  double lumens = 1;       // Best guess a lumens
  int32 sensor_value = 2;  // Actual sensor value 0-SENSOR_MAX
}

enum ListenerRequestType {
  NewPlant = 0;
  DelPlant = 1;
  NewLight = 2;
  DelLight = 3;
  UpdatePlant = 4;
}

message ListenerRequest {
  ListenerRequestType type = 1;
  oneof res {
    Plant plant = 2;
    Light light = 3;
    int64 id = 4;
  }
}

message Plant {
  int64 id = 1;
  int64 light_id = 2;
  string name = 3;
  string device_name = 4;  // The string ID of the device
  uint32 device_port = 5;  // Hardware ADC port of device
}

message Light {
  int64 id = 1;
  string name = 2;
  string device_name = 3;
  uint32 device_port = 4;
  // Do we need some sort of light specs maybe we can estimate lumens better if we know the spec
}

message ListenerResponse {
  Result res = 1;  // The Result of the last request.
   // The last request. optional in cases where we don't want to spend bandwith sending the request back.
  optional ListenerRequest res_data = 2; 
}
